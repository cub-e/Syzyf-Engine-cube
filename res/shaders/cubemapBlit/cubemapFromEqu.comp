#version 460

#define GROUP_SIZE 8
#define GROUP_THREAD_COUNT (GROUP_SIZE * GROUP_SIZE)

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = 6) in;

uniform sampler2D equirectangularMap;

layout(rgba16f, binding = 0) uniform writeonly imageCube outputImg;

const vec2 invAtan = vec2(0.1591, 0.3183);

const vec3 directions[] = {
	vec3( 1,  0,  0),
	vec3(-1,  0,  0),
	vec3( 0,  1,  0),
	vec3( 0, -1,  0),
	vec3( 0,  0,  1),
	vec3( 0,  0, -1),
};

const vec3 ups[] = {
	vec3( 0,  -1,  0),
	vec3( 0,  -1,  0),
	vec3( 0,  0,  1),
	vec3( 0,  0, -1),
	vec3( 0, -1,  0),
	vec3( 0, -1,  0),
};

const vec3 rights[] = {
	vec3( 0,  0, -1),
	vec3( 0,  0,  1),
	vec3( 1,  0,  0),
	vec3( 1,  0,  0),
	vec3( 1,  0,  0),
	vec3(-1,  0,  0),
};

vec2 SampleSphericalMap(vec3 v) {
	vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
	uv *= invAtan;
	uv += 0.5;
	return uv;
}

void main() {
	const ivec3 pixelCoord = ivec3(gl_GlobalInvocationID);

	const vec2 outputSize = imageSize(outputImg);

	if (pixelCoord.x >= outputSize.x || pixelCoord.y >= outputSize.y) {
		return;
	}

	const vec2 localUV = (pixelCoord.xy / outputSize) - 0.5;

	const vec3 forward = directions[gl_GlobalInvocationID.z];
	const vec3 up = ups[gl_GlobalInvocationID.z];
	const vec3 right = rights[gl_GlobalInvocationID.z];

	const vec3 localPos = 0.5 * forward + right * localUV.x + up * localUV.y;

	const vec2 uv = SampleSphericalMap(normalize(localPos)); // make sure to normalize localPos
	const vec3 color = texture(equirectangularMap, uv).rgb;

	imageStore(outputImg, pixelCoord, vec4(color, 0));
}