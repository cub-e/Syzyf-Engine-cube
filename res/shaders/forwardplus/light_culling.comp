#version 460

#define BLOCK_SIZE 16

#define POINT_LIGHT 0
#define SPOT_LIGHT 1
#define DIRECTIONAL_LIGHT 2

layout (local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = 1) in;

struct Plane {
	vec3 normal;
	float offset;
};

struct Frustum {
	Plane planes[4];   // left, right, top, bottom frustum planes.
};

struct Light {
	vec3 position;
	uint type;

	vec3 direction;
	float range;

	vec3 color;
	float strength;

	float spotlightAngle;
	float intensity;
	float attenuation;
	uint enabled;
};

struct Sphere {
	vec3 center;
	float  radius;
};

struct Cone {
	vec3 tipPos;
	float height;
	vec3 direction;
	float bottomRadius;
};

layout (std140, binding = 0) uniform GlobalUniforms {
	mat4 Global_ViewMatrix;
	mat4 Global_ProjectionMatrix;
	mat4 Global_VPMatrix;
	float Global_Time;
};

layout (std140, binding = 3) uniform ScreenToViewParams {
	mat4 Global_InverseProjection;
	vec2 Global_ScreenDimentions;
};

layout (std430, binding = 0) buffer in_Frustums {
	Frustum frustums[];
};
layout (std430, binding = 1) buffer LightInfo {
	vec4 Light_AmbientLight;
	int Light_LightCount;
	Light Light_LightsList[];
};
layout (std430, binding = 2) buffer O_LightIndexList {
	uint Light_OpaqueLightIndexList[];
};
layout (std430, binding = 3) buffer T_LightIndexList {
	uint Light_TransparentLightIndexList[];
};
layout (std430, binding = 4) buffer LightIndexCounter {
	uint Light_OpaqueLightIndexCounter;
	uint Light_TransparentLightIndexCounter;
};

uniform sampler2D depthTexture;
layout(rg32ui, binding = 5) uniform uimage2D Light_OpaqueLightGrid;
layout(rg32ui, binding = 6) uniform uimage2D Light_TransparentLightGrid;
layout(rg32f, binding = 7) uniform image2D testTexture;

shared uint uMinDepth;
shared uint uMaxDepth;
shared Frustum groupFrustum;

shared uint o_LightCount;
shared uint o_LightIndexStartOffset;
shared uint o_LightList[1024];

shared uint t_LightCount;
shared uint t_LightIndexStartOffset;
shared uint t_LightList[1024];

bool SphereInsidePlane(Sphere sphere, Plane plane) {
	return dot(plane.normal, sphere.center) - plane.offset < -sphere.radius;
}
bool SphereInsideFrustum(Sphere sphere, Frustum frustum, float zNear, float zFar) {
	bool result = true;

	if (sphere.center.z - sphere.radius > zNear || sphere.center.z + sphere.radius < zFar) {
		result = false;
	}

	for (int i = 0; i < 4 && result; i++) {
		if (SphereInsidePlane(sphere, frustum.planes[i])) {
			result = false;
		}
	}

	return result;
}
bool PointInsidePlane(vec3 p, Plane plane) {
	return dot(plane.normal, p) - plane.offset < 0;
}
bool ConeInsidePlane(Cone cone, Plane plane) {
	vec3 m = cross(cross(plane.normal, cone.direction), cone.direction);
	vec3 Q = cone.tipPos + cone.direction * cone.height - m * cone.bottomRadius;

	return PointInsidePlane(cone.tipPos, plane) && PointInsidePlane(Q, plane);
}
bool ConeInsideFrustum(Cone cone, Frustum frustum, float zNear, float zFar) {
	bool result = true;

	Plane nearPlane = Plane(vec3(0, 0, -1), -zNear);
	Plane farPlane = Plane(vec3(0, 0, 1), zFar);

	if (ConeInsidePlane(cone, nearPlane) || ConeInsidePlane(cone, farPlane)) {
		result = false;
	}

	for (int i = 0; i < 4 && result; i++) {
		if (ConeInsidePlane(cone, frustum.planes[i])) {
			result = false;
		}
	}

	return result;
}

vec4 ClipToView(in vec4 clip) {
	vec4 view = Global_InverseProjection * clip;
	view /= view.w;
	
	return view;
}

void MemoryBarrierWithSync() {
	groupMemoryBarrier();
	barrier();
}

void OpaqueAppendLight(uint lightIndex) {
	uint index = atomicAdd(o_LightCount, 1);
	if (index < 1024) {
		o_LightList[index] = lightIndex;
	}
}

void TransparentAppendLight(uint lightIndex) {
	uint index = atomicAdd(t_LightCount, 1);
	if (index < 1024) {
		t_LightList[index] = lightIndex;
	}
}

void main() {
	const uvec3 groupID = gl_WorkGroupID;
	const uvec3 groupThreadID = gl_LocalInvocationID;
	const uvec3 dispatchThreadID = gl_GlobalInvocationID;
	const uint groupIndex = gl_LocalInvocationIndex;
	const uvec3 numThreadGroups = gl_NumWorkGroups;
	const uvec3 numThreads = gl_NumWorkGroups * gl_WorkGroupSize;

	ivec2 texCoord = ivec2(dispatchThreadID.xy);
	float fDepth = texelFetch(depthTexture, texCoord, 0).x;

	uint uDepth = floatBitsToUint(fDepth);

	if (groupIndex == 0) {
		uMinDepth = 0xFFFFFFFF;
		uMaxDepth = 0;
		groupFrustum = frustums[groupID.y * numThreadGroups.x + groupID.x];
	}

	MemoryBarrierWithSync();

	atomicMin(uMinDepth, uDepth);
	atomicMax(uMaxDepth, uDepth);

	MemoryBarrierWithSync();

	float fMinDepth = uintBitsToFloat(uMinDepth);
	float fMaxDepth = uintBitsToFloat(uMaxDepth);

	float minDepthVS = ClipToView(vec4(0.0, 0.0, fMinDepth, 1.0)).z;
	float maxDepthVS = ClipToView(vec4(0.0, 0.0, fMaxDepth, 1.0)).z;
	float nearClipVS = ClipToView(vec4(0.0, 0.0, 0.0, 1.0)).z;

	Plane minPlane = Plane(vec3(0.0, 0.0, -1.0), -minDepthVS);

	for (uint i = groupIndex; i < Light_LightCount; i += BLOCK_SIZE * BLOCK_SIZE) {
		if (Light_LightsList[i].enabled > 0) {
			Light light = Light_LightsList[i];
			
			if (light.type == POINT_LIGHT) {
				Sphere sphere = Sphere(
					(Global_ViewMatrix * vec4(light.position, 1.0)).xyz,
					light.range
				);

				if (SphereInsideFrustum(sphere, groupFrustum, nearClipVS, maxDepthVS)) {
					TransparentAppendLight(i);

					if (!SphereInsidePlane(sphere, minPlane)) {
						OpaqueAppendLight(i);
					}
				}
			}
			else if (light.type == SPOT_LIGHT) {
				float coneRadius = tan(radians(light.spotlightAngle)) * light.range;
				Cone cone = Cone(
					(Global_ViewMatrix * vec4(light.position, 1.0)).xyz,
					light.range,
					(Global_ViewMatrix * vec4(light.direction, 0.0)).xyz,
					coneRadius
				);

				if (ConeInsideFrustum(cone, groupFrustum, nearClipVS, maxDepthVS)) {
					TransparentAppendLight(i);

					if (!ConeInsidePlane(cone, minPlane)) {
						OpaqueAppendLight(i);
					}
				}
			}
			else if (light.type == DIRECTIONAL_LIGHT) {
				TransparentAppendLight(i);
				OpaqueAppendLight(i);
			}
		}
	}

	MemoryBarrierWithSync();

	if (groupIndex == 0) {
		o_LightIndexStartOffset = atomicAdd(Light_OpaqueLightIndexCounter, o_LightCount);
		imageStore(Light_OpaqueLightGrid, ivec2(groupID.xy), uvec4(o_LightIndexStartOffset, o_LightCount, 0, 0));

		t_LightIndexStartOffset = atomicAdd(Light_TransparentLightIndexCounter, t_LightCount);
		imageStore(Light_TransparentLightGrid, ivec2(groupID.xy), uvec4(t_LightIndexStartOffset, t_LightCount, 0, 0));
	}

	MemoryBarrierWithSync();

	for (uint i = groupIndex; i < o_LightCount; i += BLOCK_SIZE * BLOCK_SIZE) {
		Light_OpaqueLightIndexList[o_LightIndexStartOffset + i] = o_LightList[i];
	}
	for (uint i = groupIndex; i < t_LightCount; i += BLOCK_SIZE * BLOCK_SIZE) {
		Light_TransparentLightIndexList[t_LightIndexStartOffset + i] = t_LightList[i];
	}
}