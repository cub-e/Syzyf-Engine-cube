#version 460

#define BLOCK_SIZE 16

layout (local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = 1) in;

struct Plane {
	vec3 normal;
	float offset;
};

struct Frustum {
	Plane planes[4];   // left, right, top, bottom frustum planes.
};

layout (std140, binding = 0) uniform ScreenToViewParams {
	mat4 Global_InverseProjection;
	vec2 Global_ScreenDimentions;
};

layout (std430, binding = 0) buffer out_Frustums {
	Frustum frustums[];
};

layout (std430, binding = 0) buffer out_Test {
	vec2 bep;
	float testing[];
};

vec4 ClipToView(in vec4 clip) {
	vec4 view = Global_InverseProjection * clip;
	view /= view.w;
	
	return view;
}

vec4 ScreenToView(in vec4 screen) {
	vec2 screenCoord = screen.xy / Global_ScreenDimentions;
	vec4 clip = vec4(
		vec2(screenCoord.x, 1.0 - screenCoord.y) * 2.0 - 1.0,
		screen.z,
		screen.w
	);

	return ClipToView(clip);
}

Plane ComputePlane(vec3 p0, vec3 p1, vec3 p2) {
	Plane plane;

	vec3 v0 = p1 - p0;

	vec3 v2 = p2 - p0;

	plane.normal = normalize(cross(v0, v2));

	plane.offset = dot(plane.normal, p0);

	return plane;
}

void main() {
	const vec3 eyePos = vec3(0.0, 0.0, 0.0);
	vec4 screenSpaceCorners[4];
	
	screenSpaceCorners[0] = vec4(
		gl_GlobalInvocationID.xy * BLOCK_SIZE,
		-1.0,
		1.0
	);
	screenSpaceCorners[1] = vec4(
		vec2(gl_GlobalInvocationID.x + 1, gl_GlobalInvocationID.y) * BLOCK_SIZE,
		-1.0,
		1.0
	);
	screenSpaceCorners[1] = vec4(
		vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y + 1) * BLOCK_SIZE,
		-1.0,
		1.0
	);
	screenSpaceCorners[1] = vec4(
		vec2(gl_GlobalInvocationID.x + 1, gl_GlobalInvocationID.y + 1) * BLOCK_SIZE,
		-1.0,
		1.0
	);

	vec3 viewSpaceCorners[4];

	for (uint i = 0; i < 4u; i++) {
		viewSpaceCorners[i] = ScreenToView(screenSpaceCorners[i]).xyz;
	}

	Frustum frustum;

	frustum.planes[0] = ComputePlane(eyePos, viewSpaceCorners[2], viewSpaceCorners[0]);
	frustum.planes[1] = ComputePlane(eyePos, viewSpaceCorners[1], viewSpaceCorners[3]);
	frustum.planes[2] = ComputePlane(eyePos, viewSpaceCorners[0], viewSpaceCorners[1]);
	frustum.planes[3] = ComputePlane(eyePos, viewSpaceCorners[3], viewSpaceCorners[2]);

	if (
		gl_GlobalInvocationID.x < gl_NumWorkGroups.x * gl_WorkGroupSize.x
		&&
		gl_GlobalInvocationID.y < gl_NumWorkGroups.y * gl_WorkGroupSize.y
	) {
		uint index = gl_GlobalInvocationID.x + (gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x);

		frustums[index] = frustum;
	}
}