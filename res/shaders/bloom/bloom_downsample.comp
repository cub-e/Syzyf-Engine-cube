#version 460

// Based on https://github.com/tgalaj/RapidGL/tree/master/src/demos/26_bloom

#define GROUP_SIZE         8
#define GROUP_THREAD_COUNT (GROUP_SIZE * GROUP_SIZE)
#define FILTER_SIZE        3
#define FILTER_RADIUS      (FILTER_SIZE / 2)
#define TILE_SIZE          (GROUP_SIZE + 2 * FILTER_RADIUS)
#define TILE_PIXEL_COUNT   (TILE_SIZE * TILE_SIZE)

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;

layout(binding = 0) uniform sampler2D inputTex;
layout(rgba16f, binding = 0) uniform writeonly image2D outputImg;

const float epsilon = 1.0e-4;

uniform vec4 treshold; // x -> threshold, yzw -> (threshold - knee, 2.0 * knee, 0.25 * knee)
uniform vec2 texelSize;
uniform int mipLevel;
uniform bool useTreshold;

shared float sm_r[TILE_PIXEL_COUNT];
shared float sm_g[TILE_PIXEL_COUNT];
shared float sm_b[TILE_PIXEL_COUNT];

// Curve = (threshold - knee, knee * 2.0, knee * 0.25)
vec4 quadraticTreshold(vec4 color, float threshold, vec3 curve) {
	// Pixel brightness
	float br = max(color.r, max(color.g, color.b));

	// Under-threshold part: quadratic curve
	float rq = clamp(br - curve.x, 0.0, curve.y);
	rq = curve.z * rq * rq;

	// Combine and apply the brightness response curve.
	color *= max(rq, br - threshold) / max(br, epsilon);

	return color;
}

float luma(vec3 c) {
	return dot(c, vec3(0.2126729, 0.7151522, 0.0721750));
}

// [Karis2013] proposed reducing the dynamic range before averaging
vec4 karisAvg(vec4 c) {
	return c / (1.0 + luma(c.rgb));
}

void storeSharedColor(int idx, vec4 c) {
	sm_r[idx] = c.r;
	sm_g[idx] = c.g;
	sm_b[idx] = c.b;
}

vec4 loadSharedColor(uint idx) {
	return vec4(sm_r[idx], sm_g[idx], sm_b[idx], 1.0);
}

void memoryBarrierWithSync() {
	groupMemoryBarrier();
	barrier();
}

void main() {
	const ivec2 pixelCoord = ivec2(gl_GlobalInvocationID);
	const ivec2 baseIndex = ivec2(gl_WorkGroupID) * GROUP_SIZE - FILTER_RADIUS;

	// The first (TILE_PIXEL_COUNT - GROUP_THREAD_COUNT) threads load at most 2 texel values
	for (int i = int(gl_LocalInvocationIndex); i < TILE_PIXEL_COUNT; i += GROUP_THREAD_COUNT) {
		const vec2 uv = (vec2(baseIndex) + 0.5) * texelSize;
		const vec2 uvOffset = vec2(i % TILE_SIZE, i / TILE_SIZE) * texelSize;
		
		const vec4 color = textureLod(inputTex, uv + uvOffset, mipLevel);
		storeSharedColor(i, color);
	}

	memoryBarrierWithSync();

	// Based on [Jimenez14] http://goo.gl/eomGso
	// center texel
	const uint sm_idx = (gl_LocalInvocationID.x + FILTER_RADIUS) + (gl_LocalInvocationID.y + FILTER_RADIUS) * TILE_SIZE;

	const vec4 A = loadSharedColor(sm_idx - TILE_SIZE - 1);
	const vec4 B = loadSharedColor(sm_idx - TILE_SIZE    );
	const vec4 C = loadSharedColor(sm_idx - TILE_SIZE + 1);
	const vec4 F = loadSharedColor(sm_idx - 1            );
	const vec4 G = loadSharedColor(sm_idx                );
	const vec4 H = loadSharedColor(sm_idx + 1            );
	const vec4 K = loadSharedColor(sm_idx + TILE_SIZE - 1);
	const vec4 L = loadSharedColor(sm_idx + TILE_SIZE    );
	const vec4 M = loadSharedColor(sm_idx + TILE_SIZE + 1);

	const vec4 D = (A + B + G + F) * 0.25;
	const vec4 E = (B + C + H + G) * 0.25;
	const vec4 I = (F + G + L + K) * 0.25;
	const vec4 J = (G + H + M + L) * 0.25;

	const vec2 div = (1.0 / 4.0) * vec2(0.5, 0.125);

	vec4 c = (
		karisAvg((D + E + I + J) * div.x)
		+
		karisAvg((A + B + G + F) * div.y)
		+
		karisAvg((B + C + H + G) * div.y)
		+
		karisAvg((F + G + L + K) * div.y)
		+
		karisAvg((G + H + M + L) * div.y)
	);
	
	if (useTreshold) {
		c = quadraticTreshold(c, treshold.x, treshold.yzw);
	}

	imageStore(outputImg, pixelCoord, c);
}