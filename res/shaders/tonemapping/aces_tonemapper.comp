#version 460

#define GROUP_SIZE         8
#define GROUP_THREAD_COUNT (GROUP_SIZE * GROUP_SIZE)

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;

layout(binding = 0) uniform sampler2D inputTex;
layout(rgba16f, binding = 0) uniform writeonly image2D outputImg;

const mat3 ACESInputMat = transpose(mat3(
	vec3(0.59719, 0.35458, 0.04823),
	vec3(0.07600, 0.90834, 0.01566),
	vec3(0.02840, 0.13383, 0.83777)
));

// ODT_SAT => XYZ => D60_2_D65 => sRGB
const mat3 ACESOutputMat = transpose(mat3(
	vec3( 1.60475, -0.53108, -0.07367),
	vec3(-0.10208,  1.10813, -0.00605),
	vec3(-0.00327, -0.07276,  1.07602)
));

vec3 RRTAndODTFit(vec3 v) {
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return a / b;
}

vec3 ACESFitted(vec3 color) {
	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit(color);

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	color = clamp(color, 0, 1);

	return color;
}

vec3 ACESFilm(vec3 x) {
	const float a = 2.51f;
	const float b = 0.03f;
	const float c = 2.43f;
	const float d = 0.59f;
	const float e = 0.14f;
	return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0, 1);
}

void main() {
	const ivec2 pixelCoord = ivec2(gl_GlobalInvocationID);

	vec2 inputSize = textureSize(inputTex, 0);

	if (pixelCoord.x >= inputSize.x || pixelCoord.y >= inputSize.y) {
		return;
	}

	vec2 uv = pixelCoord / inputSize;

	vec4 col = texture(inputTex, uv);

	col.xyz = ACESFitted(col.xyz);

	imageStore(outputImg, pixelCoord, col);
}